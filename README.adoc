= ISIM Automation Framework

== Overview

This section gives an overview of what each component in the framework does. If you just want to get something working quickly, skip this section and look at <<Setup Instructions>>. For important information to be aware of when writing playbooks, see <<Using the Framework>>. +

The ISIM automation framework is composed of five software layers. +

The isimws Python library provides the first two layers. +

=== The ISIMApplication class (isimws Library)

This is the core of the library. An ``ISIMApplication`` object is responsible for: +

* Storing the connection details to an ISIM application interface
* Establishing and maintaining a session with the API
* Ensuring the API is the correct version to support each SOAP call
* Invoking SOAP operations
* Processing any SOAP faults and connection errors
* Processing responses from the API
* Logging
//-

The class provides public functions to invoke a SOAP request, and to retrieve a SOAP object class that can be used to create the objects expected by SOAP requests. +

It is designed to respond in a standardised way that can be easily consumed by Ansible. Every public function returns an ``IBMResponse`` object, which contains the following fields expected by Ansible: +

rc:: A return code indicating the status of the request. A value of 0 indicates success, while other values indicate failure.
data:: Contains any data structure returned by the call.
warnings:: A list of warning messages generated by the call.
changed:: A boolean value indicating whether the call resulted in any change to the state of the application.
//-

It may also throw ``IBMError`` or ``IBMFatal`` exceptions, which will be caught further up the software stack. An ``IBMError`` will result in the Ansible module failing gracefully, while an ``IBMFatal`` will not be handled and result in a crash. +

=== ISIM Object Modules (isimws Library)

The isimws library provides a Python module for each type of object in the ISIM application. Each of these modules exposes functions that perform some operation on objects of that type. For example, provisioningpolicy.py provides public functions to ``search()`` and ``apply()`` provisioning policies. Each of these functions takes an ``ISIMApplication`` object as an argument, which will be used to fulfil the request, and returns an ``IBMResponse`` object as described above. +

The ISIM object class layer has two main functions: +

* Translate the different ISIM SOAP methods into an intuitive and consistent interface for the Ansible modules to interact with.
* Implement the idempotency requirement. +
//-

Each ISIM object class has an ``apply()`` function, which is the primary function for making changes to the ISIM configuration. This function takes the target configuration of an object (such as a provisioning policy) as its arguments. It checks the current state of the object to see if it exists and whether it matches the required configuration. It then dynamically determines which operations need to be performed to meet the required state and makes the SOAP requests to implement that state. +

This function is also responsible for translating intuitive object names into the ISIM DNs that the SOAP API can understand, and visa-versa. It does this through utility functions in the ``DNEncoder`` class. +

Each of the public functions provided by the ISIM object classes take the optional ``check_mode`` and ``force`` arguments. +

If ``check_mode`` is True, the function will only check to see if an update is required but not make any changes to the application state. It will return an ``IBMResponse`` object with the ``changed`` attribute indicating whether any change would have been made. +

If ``force`` is True, the function will always take action regardless of the current state. In the case of the ``apply()`` functions, this means that it will always create a new object with the target configuration, even if one already exists. This option should be used with caution as it can result in duplicate objects. +

The next layers are found in the roles directory.

=== ISIM Ansible Module (roles Directory)

The ``start_config`` Ansible role is a prerequisite for every other role in the ISIM automation framework. It loads the ISIM Ansible module, which is the mechanism for communicating with the isimws library. This module is responsible for: +

* Creating an ISIMApplication object to use for SOAP calls
* Setting up the logging configuration
* Assembling calls to the ISIM object module functions
* Passing the information received in ``IBMResponse`` objects to Ansible
* Handling errors
//-

=== Ansible Roles (roles Directory)

The Ansible roles are written in YAML and define the interface for interacting with the framework. Each role sends an action to the ISIM Ansible module, which corresponds to one of the ISIM object module functions.  Each role defines the arguments that are required with that particular action. +

The last layer is found in the examples directory. +

=== Example Playbooks (examples Directory)

The examples directory contains an example inventory, ansible.cfg file, and playbooks that use the ISIM Ansible roles. They provide a demonstration of how you would setup an automation solution using the framework and apply different configurations to an ISIM environment. +

== Setup Instructions

Follow the following steps to setup the ISIM automation framework in your environment. +

. Install Ansible.
. Install Python 3.6 or higher.
. Install the latest versions of the required Python packages using pip. These are:
* zeep
* requests
* ansible
. Install the isimws Python package. Navigate to the isimws directory and run the following (replace the version number with the version of isimws you are using):

[source,bash]
----
$ python3 setup.py sdist bdist_wheel
$ pip3 install ./dist/isimws-XXXX.XX.XX.X-py3-none-any.whl
----

[start=5]
. Setup your inventory and configure it with the ISIM hosts in your environment. Look in the examples directory for an example of how this should look. You will need to modify some of the variables in the inventory to match your environment. Key ones to watch out for are ``app_port``, ``root_dn``, ``username``, and ``password``.
. If you have multiple versions of Python installed, make sure you specify that Ansible should use the one that you installed the Python packages for. You can do this by adding an attribute in your inventory that applies to all hosts. For example:

[source,yaml]
----
ansible_python_interpreter: /Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6
----

[start=7]
. Copy the contents of the roles directory into wherever you store Ansible roles. If you are using the example playbooks, you don't need to move the roles as the included ansible.cfg file is already pointing to the roles directory. If you do move them, ensure you update your ansible.cfg file to point to where your roles are stored. For example:
----
[defaults]
roles_path = ~/isim-ansible/roles/
----

[start=8]
. You should now be able to run Ansible playbooks that make use of the ISIM Ansible roles. Look in the examples directory for examples of how to use the roles in your playbooks. For example, run:

[source,bash]
----
ansible-playbook â€“i ./inventories/demo demo.yml
----
//-

== Using the Framework

There are a few things to be aware of when writing playbooks.

=== Identifying Objects

Usually, objects in ISIM are uniquely identified by their ISIM DN, for example "erglobalid=1502785756771677767,ou=0,ou=people,erglobalid=00000000000000000000,ou=demo,dc=com". However, ISIM DNs are poorly suited for use in playbooks because they can change between environments and make the YAML configuration files very unintuitive to work with. +

The ISIM automation framework overcomes this problem by referring to objects using a combination of their name and the organizational container that they reside in. Anytime you need to refer to an object, you need to provide these two pieces of information. +

This allows us to refer to objects in playbooks independently of their ISIM DN, however it also introduces a limitation. Normally, ISIM allows you to have as many objects of the same type with the same name in the same container as you like. It doesn't matter because they are all uniquely identifed by their DN. However, this is no longer possible once we start uniquely identifying objects by their name and container. Therefore, the ISIM automation framework only works in environments where object names are unique within their container. For example, you can't have two services with the same parent container. It is fine to have multiple services with the same name as long as they are in seperate containers. +

It should be noted that container objects have an extra piece of identifying information, which is their container profile. Therefore, it is possible to have two containers with the same name and the same parent container if one is an admin domain and the other is an organizational unit, for example.

=== Container Paths

Since we will be referring to containers frequently in order to identify objects, the framework also introduces a new syntax for referring to containers in the ISIM organizational hierarchy. Instead of using ISIM DNs, any container in the hierarchy can be identified using its "container path". +

A container path should be in the following format: +
----
//organization_name//profile::container_name//profile::container_name
----
Valid values for profile are 'ou' (organizational unit), 'bp' (business partner unit), 'lo' (location), or 'ad' (admin domain). The root container (i.e. the parent of all organizations) is specified as "//". For example, the following are all valid container paths: +
----
//IBM//lo::Sydney//ou::finance

//IBM

//

----

=== Idempotency

The framework is designed to be truly idempotent. All the apply roles will dynamically choose whether to to create or modify based on whether an object with the same name exists in the same container. Only attributes which differ from the existing object will be changed. For this reason, the name and container path of an existing object can't be changed because they are used to identify the object. If they don't match an existing object, a new object will be created with the specified name and container path. +

As mentioned above, you can use the ``force`` argument to override this behaviour and force the role to create a new object regardless of the current state, but be careful using this as you can end up with duplicate objects. +